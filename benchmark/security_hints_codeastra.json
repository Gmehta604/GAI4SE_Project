{
  "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_81_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_81_bad.cpp\nLabel Definition File: CWE121_Stack_Based_Buffer_Overflow__CWE129.label.xml\nTemplate File: sources-sinks-81_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 121 Stack Based Buffer Overflow\n * BadSource: fgets Read data from the console using fgets()\n * GoodSource: Larger than zero but less than 10\n * Sinks:\n *    GoodSink: Ensure the array index is valid\n *    BadSink : Improperly check the array index by not checking the upper bound\n * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_81.h\"\n\nnamespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_81\n{\n\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_81_bad::action(int data) const\n{\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n\n}\n#endif /* OMITBAD */\n\n/*\n * @description\n * CWE: 121 Stack Based Buffer Overflow\n * BadSource: fgets Read data from the console using fgets()\n * GoodSource: Larger than zero but less than 10\n * Sinks:\n *    GoodSink: Ensure the array index is valid\n *    BadSink : Improperly check the array index by not checking the upper bound\n * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference\n *\n * */\n#ifndef OMITGOOD\n\n#include \"std_testcase.h\"\n#include \"CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_81.h\"\n\nnamespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_81\n{\n\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_81_good::action(int data) const\n{\n    int buffer[10];\n    int i;\n    /* Good practice:",
  "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_82_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_82_bad.cpp\nLabel Definition File: CWE121_Stack_Based_Buffer_Overflow__CWE129.label.xml\nTemplate File: sources-sinks-82_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 121 Stack Based Buffer Overflow\n * BadSource: fgets Read data from the console using fgets()\n * GoodSource: Larger than zero but less than 10\n * Sinks:\n *    GoodSink: Ensure the array index is valid\n *    BadSink : Improperly check the array index by not checking the upper bound\n * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_82.h\"\n\nnamespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_82\n{\n\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_82_bad::action(int data)\n{\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n\n}\n#endif /* OMITBAD */\n\n/*\n * @description\n * CWE: 121 Stack Based Buffer Overflow\n * BadSource: fgets Read data from the console using fgets()\n * GoodSource: Larger than zero but less than 10\n * Sinks:\n *    GoodSink: Ensure the array index is valid\n *    BadSink : Improperly check the array index by not checking the upper bound\n * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer\n *\n * */\n#ifndef OMITGOOD\n\n#include \"std_testcase.h\"\n#include \"CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_82.h\"\n\nnamespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_82\n{\n\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_82_good::action(int data)\n{\n    int buffer[10];\n    int i;\n    if (data >=",
  "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_83_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_83_bad.cpp\nLabel Definition File: CWE121_Stack_Based_Buffer_Overflow__CWE129.label.xml\nTemplate File: sources-sinks-83_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 121 Stack Based Buffer Overflow\n * BadSource: fgets Read data from the console using fgets()\n * GoodSource: Larger than zero but less than 10\n * Sinks:\n *    GoodSink: Ensure the array index is valid\n *    BadSink : Improperly check the array index by not checking the upper bound\n * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_83.h\"\n\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\nnamespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_83\n{\nCWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_83_bad::CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_83_bad(int dataCopy)\n{\n    data = dataCopy;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n}\n\nCWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_83_bad::~CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_83_bad()\n{\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n}\n#endif /* OMITBAD */\n\nnamespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_83_good\n{\nCWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_83_good::CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_83_good(int dataCopy)\n{\n    data = dataCopy;\n}\n\nCWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_83_good::~CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_83_good()\n{\n    if (data >= 0 && data < 10)\n    {\n        buffer[data] = 1;\n    }\n    else\n    {\n        printLine(\"ERROR: Array index is out of bounds.\");\n    }\n}\n}\n\nint main()\n{\n    int data = 0;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129",
  "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_84_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_84_bad.cpp\nLabel Definition File: CWE121_Stack_Based_Buffer_Overflow__CWE129.label.xml\nTemplate File: sources-sinks-84_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 121 Stack Based Buffer Overflow\n * BadSource: fgets Read data from the console using fgets()\n * GoodSource: Larger than zero but less than 10\n * Sinks:\n *    GoodSink: Ensure the array index is valid\n *    BadSink : Improperly check the array index by not checking the upper bound\n * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_84.h\"\n\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\nnamespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_84\n{\nCWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_84_bad::CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_84_bad(int dataCopy)\n{\n    data = dataCopy;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n}\n\nCWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_84_bad::~CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_84_bad()\n{\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n}\n#endif /* OMITBAD */\n\n/*\n * @description\n * CWE: 121 Stack Based Buffer Overflow\n * BadSource: fgets Read data from the console using fgets()\n * GoodSource: Larger than zero but less than 10\n * Sinks:\n *    GoodSink: Ensure the array index is valid\n *    BadSink : Improperly check the array index by not checking the upper bound\n * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use\n *\n * */\n#ifndef OMITGOOD\n\n#include \"std_testcase.h\"\n#include \"CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_84.h\"\n\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\n\nnamespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_84\n{\nCWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_84_",
  "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_81_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_81_bad.cpp\nLabel Definition File: CWE121_Stack_Based_Buffer_Overflow__CWE129.label.xml\nTemplate File: sources-sinks-81_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 121 Stack Based Buffer Overflow\n * BadSource: fscanf Read data from the console using fscanf()\n * GoodSource: Larger than zero but less than 10\n * Sinks:\n *    GoodSink: Ensure the array index is valid\n *    BadSink : Improperly check the array index by not checking the upper bound\n * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_81.h\"\n\nnamespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_81\n{\n\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_81_bad::action(int data) const\n{\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n\n}\n#endif /* OMITBAD */\n\nnamespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_81_good\n{\n\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_81_good::action(int data) const\n{\n    int buffer[10];\n    if (data >= 0 && data < 10)\n    {\n        buffer[data] = 1;\n    }\n    else\n    {\n        printLine(\"ERROR: Array index is out of bounds.\");\n    }\n}\n\n}\n\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_81_bad::action(int data) const\n{\n    int buffer[10];\n    if (data >= 0)\n    {\n        buffer[data] = 1;\n    }\n}\n\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_81_good::action(int data) const\n{\n    int",
  "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82_bad.cpp\nLabel Definition File: CWE121_Stack_Based_Buffer_Overflow__CWE129.label.xml\nTemplate File: sources-sinks-82_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 121 Stack Based Buffer Overflow\n * BadSource: fscanf Read data from the console using fscanf()\n * GoodSource: Larger than zero but less than 10\n * Sinks:\n *    GoodSink: Ensure the array index is valid\n *    BadSink : Improperly check the array index by not checking the upper bound\n * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82.h\"\n\nnamespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82\n{\n\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82_bad::action(int data)\n{\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n\n}\n#endif /* OMITBAD */\n\nnamespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82_good\n{\n\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82_good::action(int data)\n{\n    int buffer[10];\n    if (data >= 0 && data < 10)\n    {\n        buffer[data] = 1;\n    }\n    else\n    {\n        printLine(\"ERROR: Array index is out of bounds.\");\n    }\n}\n\n}\n\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82_bad::action(int data)\n{\n    int buffer[10];\n    if (data >= 0)\n    {\n        buffer[data] = 1;\n    }\n}\n\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82_good::action(int data)\n{\n    int buffer[1",
  "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_83_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_83_bad.cpp\nLabel Definition File: CWE121_Stack_Based_Buffer_Overflow__CWE129.label.xml\nTemplate File: sources-sinks-83_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 121 Stack Based Buffer Overflow\n * BadSource: fscanf Read data from the console using fscanf()\n * GoodSource: Larger than zero but less than 10\n * Sinks:\n *    GoodSink: Ensure the array index is valid\n *    BadSink : Improperly check the array index by not checking the upper bound\n * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_83.h\"\n\nnamespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_83\n{\nCWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_83_bad::CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_83_bad(int dataCopy)\n{\n    data = dataCopy;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n}\n\nCWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_83_bad::~CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_83_bad()\n{\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n}\n#endif /* OMITBAD */\n\n/*\n * @description\n * CWE: 121 Stack Based Buffer Overflow\n * BadSource: fscanf Read data from the console using fscanf()\n * GoodSource: Larger than zero but less than 10\n * Sinks:\n *    GoodSink: Ensure the array index is valid\n *    BadSink : Improperly check the array index by not checking the upper bound\n * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack\n *\n * */\n#ifndef OMITGOOD\n\n#include \"std_testcase.h\"\n#include \"CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_83.h\"\n\nnamespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_83\n{\nCWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_83_good::CWE121_Stack_Based_Buffer_Overflow__CWE129_",
  "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_84_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_84_bad.cpp\nLabel Definition File: CWE121_Stack_Based_Buffer_Overflow__CWE129.label.xml\nTemplate File: sources-sinks-84_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 121 Stack Based Buffer Overflow\n * BadSource: fscanf Read data from the console using fscanf()\n * GoodSource: Larger than zero but less than 10\n * Sinks:\n *    GoodSink: Ensure the array index is valid\n *    BadSink : Improperly check the array index by not checking the upper bound\n * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_84.h\"\n\nnamespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_84\n{\nCWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_84_bad::CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_84_bad(int dataCopy)\n{\n    data = dataCopy;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n}\n\nCWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_84_bad::~CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_84_bad()\n{\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n}\n#endif /* OMITBAD */\n\nnamespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_84\n{\nCWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_84_good::CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_84_good(int dataCopy)\n{\n    data = dataCopy;\n    /* SAFE: Ensure the array index is valid */\n    if (data >= 0 && data < 10)\n    {\n        buffer[data] = 1;\n    }\n    else\n    {\n        printLine(\"ERROR: Array index is out of bounds.\");\n    }\n}\n}\n\nint main()\n{\n    int data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_84_bad badObject(data);\n    return 0;\n}",
  "CWE190_Integer_Overflow__char_fscanf_add_81_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__char_fscanf_add_81_bad.cpp\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-81_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: fscanf Read data from the console using fscanf()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: add\n *    GoodSink: Ensure there will not be an overflow before adding 1 to data\n *    BadSink : Add 1 to data, which can cause an overflow\n * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE190_Integer_Overflow__char_fscanf_add_81.h\"\n\nnamespace CWE190_Integer_Overflow__char_fscanf_add_81\n{\n\nvoid CWE190_Integer_Overflow__char_fscanf_add_81_bad::action(char data) const\n{\n    {\n        /* POTENTIAL FLAW: Adding 1 to data could cause an overflow */\n        char result = data + 1;\n        printHexCharLine(result);\n    }\n}\n\n}\n#endif /* OMITBAD */\n\nnamespace CWE190_Integer_Overflow__char_fscanf_add_81_good\n{\n\nvoid CWE190_Integer_Overflow__char_fscanf_add_81_good::action(char data) const\n{\n    /* SAFE CODE: Ensure there will not be an overflow before adding 1 to data */\n    if (data >= '0' && data <= '9')\n    {\n        char result = data + 1;\n        printHexCharLine(result);\n    }\n}\n\n}\n\nvoid CWE190_Integer_Overflow__char_fscanf_add_81_bad::action(char data) const\n{\n    char result = data + 1;\n    printHexCharLine(result);\n}\n\nvoid CWE190_Integer_Overflow__char_fscanf_add_81_good::action(char data) const\n{\n    if (data >= '0' && data <= '9')\n    {\n        char result = data + 1;\n        printHexCharLine(result);\n    }",
  "CWE190_Integer_Overflow__char_fscanf_add_82_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__char_fscanf_add_82_bad.cpp\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-82_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: fscanf Read data from the console using fscanf()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: add\n *    GoodSink: Ensure there will not be an overflow before adding 1 to data\n *    BadSink : Add 1 to data, which can cause an overflow\n * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE190_Integer_Overflow__char_fscanf_add_82.h\"\n\nnamespace CWE190_Integer_Overflow__char_fscanf_add_82\n{\n\nvoid CWE190_Integer_Overflow__char_fscanf_add_82_bad::action(char data)\n{\n    {\n        /* POTENTIAL FLAW: Adding 1 to data could cause an overflow */\n        char result = data + 1;\n        printHexCharLine(result);\n    }\n}\n\n}\n#endif /* OMITBAD */\n\n/*\n * @description\n * CWE: 190 Integer Overflow\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: add\n *    GoodSink: Ensure there will not be an overflow before adding 1 to data\n *    BadSink : Add 1 to data, which can cause an overflow\n * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer\n *\n * */\n#ifndef OMITGOOD\n\n#include \"std_testcase.h\"\n#include \"CWE190_Integer_Overflow__char_fscanf_add_82.h\"\n\nnamespace CWE190_Integer_Overflow__char_fscanf_add_82\n{\n\nvoid CWE190_Integer_Overflow__char_fscanf_add_82_good::action(char data)\n{\n    /* SAFE CODE: Ensure there will not be an overflow before adding 1 to data */\n    char result = data;\n    if (result >= '0' && result <= '9')",
  "CWE190_Integer_Overflow__char_fscanf_add_83_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__char_fscanf_add_83_bad.cpp\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-83_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: fscanf Read data from the console using fscanf()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: add\n *    GoodSink: Ensure there will not be an overflow before adding 1 to data\n *    BadSink : Add 1 to data, which can cause an overflow\n * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE190_Integer_Overflow__char_fscanf_add_83.h\"\n\nnamespace CWE190_Integer_Overflow__char_fscanf_add_83\n{\nCWE190_Integer_Overflow__char_fscanf_add_83_bad::CWE190_Integer_Overflow__char_fscanf_add_83_bad(char dataCopy)\n{\n    data = dataCopy;\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (stdin, \"%c\", &data);\n}\n\nCWE190_Integer_Overflow__char_fscanf_add_83_bad::~CWE190_Integer_Overflow__char_fscanf_add_83_bad()\n{\n    {\n        /* POTENTIAL FLAW: Adding 1 to data could cause an overflow */\n        char result = data + 1;\n        printHexCharLine(result);\n    }\n}\n}\n#endif /* OMITBAD */\n\nnamespace CWE190_Integer_Overflow__char_fscanf_add_83\n{\nCWE190_Integer_Overflow__char_fscanf_add_83_good::CWE190_Integer_Overflow__char_fscanf_add_83_good()\n{\n    data = 0;\n}\n\nCWE190_Integer_Overflow__char_fscanf_add_83_good::~CWE190_Integer_Overflow__char_fscanf_add_83_good()\n{\n    /* SAFE: Check if data is within bounds before adding 1 */\n    if (data < 0x7F)\n    {\n        char result = data + 1;\n        printHexCharLine(result);\n    }\n}\n}\n\nvoid CWE190_Integer_Overflow__char_fscanf_add_83_test()\n{\n    char data = 0;\n    char result;\n\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (std",
  "CWE190_Integer_Overflow__char_fscanf_add_84_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__char_fscanf_add_84_bad.cpp\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-84_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: fscanf Read data from the console using fscanf()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: add\n *    GoodSink: Ensure there will not be an overflow before adding 1 to data\n *    BadSink : Add 1 to data, which can cause an overflow\n * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE190_Integer_Overflow__char_fscanf_add_84.h\"\n\nnamespace CWE190_Integer_Overflow__char_fscanf_add_84\n{\nCWE190_Integer_Overflow__char_fscanf_add_84_bad::CWE190_Integer_Overflow__char_fscanf_add_84_bad(char dataCopy)\n{\n    data = dataCopy;\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (stdin, \"%c\", &data);\n}\n\nCWE190_Integer_Overflow__char_fscanf_add_84_bad::~CWE190_Integer_Overflow__char_fscanf_add_84_bad()\n{\n    {\n        /* POTENTIAL FLAW: Adding 1 to data could cause an overflow */\n        char result = data + 1;\n        printHexCharLine(result);\n    }\n}\n}\n#endif /* OMITBAD */\n\n/*\n * @description\n * CWE: 190 Integer Overflow\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: add\n *    GoodSink: Ensure there will not be an overflow before adding 1 to data\n *    BadSink : Add 1 to data, which can cause an overflow\n * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use\n *\n * */\n#ifndef OMITGOOD\n\n#include \"std_testcase.h\"\n#include \"CWE190_Integer_Overflow__char_fscanf_add_84.h\"\n\nnamespace CWE190_Integer_Overflow__char_fscanf_add_84\n{\nCWE190_Integer_Overflow__char_fscanf_add_84_good::CWE190_Integer_Overflow__char_fscanf_add_84_good(char dataCopy)\n{\n    data = dataCopy;\n    /* SAFE: Data is",
  "CWE190_Integer_Overflow__char_fscanf_multiply_81_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__char_fscanf_multiply_81_bad.cpp\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-81_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: fscanf Read data from the console using fscanf()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: multiply\n *    GoodSink: Ensure there will not be an overflow before multiplying data by 2\n *    BadSink : If data is positive, multiply by 2, which can cause an overflow\n * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE190_Integer_Overflow__char_fscanf_multiply_81.h\"\n\nnamespace CWE190_Integer_Overflow__char_fscanf_multiply_81\n{\n\nvoid CWE190_Integer_Overflow__char_fscanf_multiply_81_bad::action(char data) const\n{\n    if(data > 0) /* ensure we won't have an underflow */\n    {\n        /* POTENTIAL FLAW: if (data*2) > CHAR_MAX, this will overflow */\n        char result = data * 2;\n        printHexCharLine(result);\n    }\n}\n\n}\n#endif /* OMITBAD */\n\nnamespace CWE190_Integer_Overflow__char_fscanf_multiply_81_good\n{\n\nvoid CWE190_Integer_Overflow__char_fscanf_multiply_81_good::action(char data) const\n{\n    if(data > 0)\n    {\n        /* SAFE: Ensure there will not be an overflow before multiplying data by 2 */\n        char result = data;\n        char safeResult = result * 2;\n        printHexCharLine(safeResult);\n    }\n}\n\n}\n\nnamespace CWE190_Integer_Overflow__char_fscanf_multiply_81_bad\n{\n\nvoid CWE190_Integer_Overflow__char_fscanf_multiply_81_bad::action(char data) const\n{\n    if(data > 0)\n    {\n        /* POTENTIAL FLAW: if (data*2) > CHAR_MAX, this will overflow */\n        char result = data;\n        char safeResult = result * 2;\n        printHexCharLine(",
  "CWE190_Integer_Overflow__char_fscanf_multiply_82_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__char_fscanf_multiply_82_bad.cpp\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-82_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: fscanf Read data from the console using fscanf()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: multiply\n *    GoodSink: Ensure there will not be an overflow before multiplying data by 2\n *    BadSink : If data is positive, multiply by 2, which can cause an overflow\n * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE190_Integer_Overflow__char_fscanf_multiply_82.h\"\n\nnamespace CWE190_Integer_Overflow__char_fscanf_multiply_82\n{\n\nvoid CWE190_Integer_Overflow__char_fscanf_multiply_82_bad::action(char data)\n{\n    if(data > 0) /* ensure we won't have an underflow */\n    {\n        /* POTENTIAL FLAW: if (data*2) > CHAR_MAX, this will overflow */\n        char result = data * 2;\n        printHexCharLine(result);\n    }\n}\n\n}\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n#include \"std_testcase.h\"\n#include \"CWE190_Integer_Overflow__char_fscanf_multiply_82.h\"\n\nnamespace CWE190_Integer_Overflow__char_fscanf_multiply_82\n{\n\nvoid CWE190_Integer_Overflow__char_fscanf_multiply_82_good::action(char data)\n{\n    if(data > 0) /* ensure we won't have an underflow */\n    {\n        char result = data;\n        printHexCharLine(result);\n        char safeResult = data * 2;\n        printHexCharLine(safeResult);\n    }\n}\n\n}\n#endif /* OMITGOOD */\n\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: fscanf Read data from the console using fscanf()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: multiply\n *    GoodSink: Ensure there will not be",
  "CWE190_Integer_Overflow__char_fscanf_multiply_83_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__char_fscanf_multiply_83_bad.cpp\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-83_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: fscanf Read data from the console using fscanf()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: multiply\n *    GoodSink: Ensure there will not be an overflow before multiplying data by 2\n *    BadSink : If data is positive, multiply by 2, which can cause an overflow\n * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE190_Integer_Overflow__char_fscanf_multiply_83.h\"\n\nnamespace CWE190_Integer_Overflow__char_fscanf_multiply_83\n{\nCWE190_Integer_Overflow__char_fscanf_multiply_83_bad::CWE190_Integer_Overflow__char_fscanf_multiply_83_bad(char dataCopy)\n{\n    data = dataCopy;\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (stdin, \"%c\", &data);\n}\n\nCWE190_Integer_Overflow__char_fscanf_multiply_83_bad::~CWE190_Integer_Overflow__char_fscanf_multiply_83_bad()\n{\n    if(data > 0) /* ensure we won't have an underflow */\n    {\n        /* POTENTIAL FLAW: if (data*2) > CHAR_MAX, this will overflow */\n        char result = data * 2;\n        printHexCharLine(result);\n    }\n}\n}\n#endif /* OMITBAD */\n\n/*\n * @description\n * CWE: 190 Integer Overflow\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: multiply\n *    GoodSink: Ensure there will not be an overflow before multiplying data by 2\n *    BadSink : If data is positive, multiply by 2, which can cause an overflow\n * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack\n *\n * */\n#ifndef OMITGOOD\n\n#include \"std_testcase.h\"\n#include \"CWE190_Integer_Overflow__char_fscanf_multiply_83.h\"\n\nnamespace CWE190_Integer_Overflow__char_fscanf_multiply_83\n{\nCWE190_Integer_Overflow__char_fscanf_multiply_83_good::CWE190_Integer_Overflow__char_fscanf_multiply_83_good(char dataCopy)\n{\n    data = dataCopy;\n}",
  "CWE190_Integer_Overflow__char_fscanf_multiply_84_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__char_fscanf_multiply_84_bad.cpp\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-84_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: fscanf Read data from the console using fscanf()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: multiply\n *    GoodSink: Ensure there will not be an overflow before multiplying data by 2\n *    BadSink : If data is positive, multiply by 2, which can cause an overflow\n * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE190_Integer_Overflow__char_fscanf_multiply_84.h\"\n\nnamespace CWE190_Integer_Overflow__char_fscanf_multiply_84\n{\nCWE190_Integer_Overflow__char_fscanf_multiply_84_bad::CWE190_Integer_Overflow__char_fscanf_multiply_84_bad(char dataCopy)\n{\n    data = dataCopy;\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (stdin, \"%c\", &data);\n}\n\nCWE190_Integer_Overflow__char_fscanf_multiply_84_bad::~CWE190_Integer_Overflow__char_fscanf_multiply_84_bad()\n{\n    if(data > 0) /* ensure we won't have an underflow */\n    {\n        /* POTENTIAL FLAW: if (data*2) > CHAR_MAX, this will overflow */\n        char result = data * 2;\n        printHexCharLine(result);\n    }\n}\n}\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n#include \"std_testcase.h\"\n#include \"CWE190_Integer_Overflow__char_fscanf_multiply_84.h\"\n\nnamespace CWE190_Integer_Overflow__char_fscanf_multiply_84\n{\nCWE190_Integer_Overflow__char_fscanf_multiply_84_good::CWE190_Integer_Overflow__char_fscanf_multiply_84_good()\n{\n    data = 2;\n}\n\nCWE190_Integer_Overflow__char_fscanf_multiply_84_good::~CWE190_Integer_Overflow__char_fscanf_multiply_84_good()\n{\n    /* SAFE: Ensure there will not be an overflow before multiplying data */\n    char result = data * 2;\n    printHexCharLine(result);\n}\n}\n#endif /* OMITGOOD */\n\n/*\n * @description\n * CWE: 190 Integer Overflow\n * Bad",
  "CWE476_NULL_Pointer_Dereference__char_81_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE476_NULL_Pointer_Dereference__char_81_bad.cpp\nLabel Definition File: CWE476_NULL_Pointer_Dereference.label.xml\nTemplate File: sources-sinks-81_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 476 NULL Pointer Dereference\n * BadSource:  Set data to NULL\n * GoodSource: Initialize data\n * Sinks:\n *    GoodSink: Check for NULL before attempting to print data\n *    BadSink : Print data\n * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE476_NULL_Pointer_Dereference__char_81.h\"\n\nnamespace CWE476_NULL_Pointer_Dereference__char_81\n{\n\nvoid CWE476_NULL_Pointer_Dereference__char_81_bad::action(char * data) const\n{\n    /* POTENTIAL FLAW: Attempt to use data, which may be NULL */\n    /* printLine() checks for NULL, so we cannot use it here */\n    printHexCharLine(data[0]);\n}\n\n}\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n#include \"std_testcase.h\"\n#include \"CWE476_NULL_Pointer_Dereference__char_81.h\"\n\nnamespace CWE476_NULL_Pointer_Dereference__char_81\n{\n\nvoid CWE476_NULL_Pointer_Dereference__char_81_good::action(char * data) const\n{\n    /* CHECK FOR NULL BEFORE USING */\n    if (data != NULL)\n    {\n        printLine(\"Data: 0x%x\", data[0]);\n    }\n}\n\n}\n#endif /* OMITGOOD */\n\n/*\n * @description\n * CWE: 476 NULL Pointer Dereference\n * BadSource:  Set data to NULL\n * GoodSource: Initialize data\n * Sinks:\n *    GoodSink: Check for NULL before attempting to print data\n *    BadSink : Print data\n * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference\n *\n * */\nvoid printHexCharLine",
  "CWE476_NULL_Pointer_Dereference__char_82_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE476_NULL_Pointer_Dereference__char_82_bad.cpp\nLabel Definition File: CWE476_NULL_Pointer_Dereference.label.xml\nTemplate File: sources-sinks-82_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 476 NULL Pointer Dereference\n * BadSource:  Set data to NULL\n * GoodSource: Initialize data\n * Sinks:\n *    GoodSink: Check for NULL before attempting to print data\n *    BadSink : Print data\n * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE476_NULL_Pointer_Dereference__char_82.h\"\n\nnamespace CWE476_NULL_Pointer_Dereference__char_82\n{\n\nvoid CWE476_NULL_Pointer_Dereference__char_82_bad::action(char * data)\n{\n    /* POTENTIAL FLAW: Attempt to use data, which may be NULL */\n    /* printLine() checks for NULL, so we cannot use it here */\n    printHexCharLine(data[0]);\n}\n\n}\n#endif /* OMITBAD */\n\n/*\n * @description\n * CWE: 476 NULL Pointer Dereference\n * GoodSource: Initialize data\n * Sinks:\n *    GoodSink: Check for NULL before attempting to print data\n *    BadSink : Print data\n * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer\n *\n * */\n#ifndef OMITGOOD\n\n#include \"std_testcase.h\"\n#include \"CWE476_NULL_Pointer_Dereference__char_82.h\"\n\nnamespace CWE476_NULL_Pointer_Dereference__char_82\n{\n\nvoid CWE476_NULL_Pointer_Dereference__char_82_good::action(char * data)\n{\n    /* CHECK FOR NULL BEFORE USING */\n    if (data != NULL)\n    {\n        printLine(\"Data: %c\", *data);\n    }\n}\n\n}\n#endif /* OMITGOOD */\n\n/*\n * @description\n * CWE: 476 NULL Pointer Dereference",
  "CWE476_NULL_Pointer_Dereference__class_81_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE476_NULL_Pointer_Dereference__class_81_bad.cpp\nLabel Definition File: CWE476_NULL_Pointer_Dereference__class.label.xml\nTemplate File: sources-sinks-81_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 476 NULL Pointer Dereference\n * BadSource:  Set data to NULL\n * GoodSource: Initialize data\n * Sinks:\n *    GoodSink: Check data for NULL before attempting to print data->a\n *    BadSink : Print data->a\n * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE476_NULL_Pointer_Dereference__class_81.h\"\n\nnamespace CWE476_NULL_Pointer_Dereference__class_81\n{\n\nvoid CWE476_NULL_Pointer_Dereference__class_81_bad::action(TwoIntsClass * data) const\n{\n    /* POTENTIAL FLAW: Attempt to use data, which may be NULL */\n    printIntLine(data->intOne);\n    /* avoid memory leak - deleting a NULL pointer is a no-op in C++ so no need to check for NULL */\n    delete data;\n}\n\n}\n#endif /* OMITBAD */\n\n/*\n * @description\n * CWE: 476 NULL Pointer Dereference\n * GoodSource: Initialize data\n * Sinks:\n *    GoodSink: Check data for NULL before attempting to print data->a\n *    BadSink : Print data->a\n * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference\n *\n **/\n#ifndef OMITGOOD\n\n#include \"std_testcase.h\"\n#include \"CWE476_NULL_Pointer_Dereference__class_81.h\"\n\nnamespace CWE476_NULL_Pointer_Dereference__class_81\n{\n\nvoid CWE476_NULL_Pointer_Dereference__class_81_good::action(TwoIntsClass * data) const\n{\n    /* CHECK FOR NULL POINTER */\n    if (data != NULL)\n    {\n        printIntLine(data->intOne);\n    }\n}\n\n}\n#endif /* OMITGOOD */\n\n/*\n * @description\n * CWE: 476 NULL",
  "CWE476_NULL_Pointer_Dereference__class_82_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE476_NULL_Pointer_Dereference__class_82_bad.cpp\nLabel Definition File: CWE476_NULL_Pointer_Dereference__class.label.xml\nTemplate File: sources-sinks-82_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 476 NULL Pointer Dereference\n * BadSource:  Set data to NULL\n * GoodSource: Initialize data\n * Sinks:\n *    GoodSink: Check data for NULL before attempting to print data->a\n *    BadSink : Print data->a\n * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE476_NULL_Pointer_Dereference__class_82.h\"\n\nnamespace CWE476_NULL_Pointer_Dereference__class_82\n{\n\nvoid CWE476_NULL_Pointer_Dereference__class_82_bad::action(TwoIntsClass * data)\n{\n    /* POTENTIAL FLAW: Attempt to use data, which may be NULL */\n    printIntLine(data->intOne);\n    /* avoid memory leak - deleting a NULL pointer is a no-op in C++ so no need to check for NULL */\n    delete data;\n}\n\n}\n#endif /* OMITBAD */\n\nnamespace CWE476_NULL_Pointer_Dereference__class_82\n{\n\nvoid CWE476_NULL_Pointer_Dereference__class_82_good::action(TwoIntsClass * data)\n{\n    if (data != NULL)\n    {\n        printIntLine(data->intOne);\n    }\n}\n\n}\n\nvoid printIntLine(int value)\n{\n    std::cout << value << std::endl;\n}",
  "CWE476_NULL_Pointer_Dereference__int64_t_81_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE476_NULL_Pointer_Dereference__int64_t_81_bad.cpp\nLabel Definition File: CWE476_NULL_Pointer_Dereference.label.xml\nTemplate File: sources-sinks-81_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 476 NULL Pointer Dereference\n * BadSource:  Set data to NULL\n * GoodSource: Initialize data\n * Sinks:\n *    GoodSink: Check for NULL before attempting to print data\n *    BadSink : Print data\n * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE476_NULL_Pointer_Dereference__int64_t_81.h\"\n\nnamespace CWE476_NULL_Pointer_Dereference__int64_t_81\n{\n\nvoid CWE476_NULL_Pointer_Dereference__int64_t_81_bad::action(int64_t * data) const\n{\n    /* POTENTIAL FLAW: Attempt to use data, which may be NULL */\n    printLongLongLine(*data);\n}\n\n}\n#endif /* OMITBAD */\n\nnamespace CWE476_NULL_Pointer_Dereference__int64_t_81_good\n{\n\nvoid CWE476_NULL_Pointer_Dereference__int64_t_81_good::action(int64_t * data) const\n{\n    if (data != NULL)\n    {\n        printLongLongLine(*data);\n    }\n}\n\n}\n\nvoid printLongLongLine(int64_t value)\n{\n    std::cout << \"Long long value: \" << value << std::endl;\n}",
  "CWE476_NULL_Pointer_Dereference__int64_t_82_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE476_NULL_Pointer_Dereference__int64_t_82_bad.cpp\nLabel Definition File: CWE476_NULL_Pointer_Dereference.label.xml\nTemplate File: sources-sinks-82_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 476 NULL Pointer Dereference\n * BadSource:  Set data to NULL\n * GoodSource: Initialize data\n * Sinks:\n *    GoodSink: Check for NULL before attempting to print data\n *    BadSink : Print data\n * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE476_NULL_Pointer_Dereference__int64_t_82.h\"\n\nnamespace CWE476_NULL_Pointer_Dereference__int64_t_82\n{\n\nvoid CWE476_NULL_Pointer_Dereference__int64_t_82_bad::action(int64_t * data)\n{\n    /* POTENTIAL FLAW: Attempt to use data, which may be NULL */\n    printLongLongLine(*data);\n}\n\n}\n#endif /* OMITBAD */\n\n/*\n * @description\n * CWE: 476 NULL Pointer Dereference\n * GoodSource: Initialize data\n * Sinks:\n *    GoodSink: Check for NULL before attempting to print data\n *    BadSink : Print data\n * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer\n *\n * */\n#ifndef OMITGOOD\n\n#include \"std_testcase.h\"\n#include \"CWE476_NULL_Pointer_Dereference__int64_t_82.h\"\n\nnamespace CWE476_NULL_Pointer_Dereference__int64_t_82\n{\n\nvoid CWE476_NULL_Pointer_Dereference__int64_t_82_good::action(int64_t * data)\n{\n    /* FIXED CODE: Check for NULL before attempting to use data */\n    if (data != NULL)\n    {\n        printLongLongLine(*data);\n    }\n}\n\n}\n#endif /* OMITGOOD */\n\n/*",
  "CWE476_NULL_Pointer_Dereference__int_81_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE476_NULL_Pointer_Dereference__int_81_bad.cpp\nLabel Definition File: CWE476_NULL_Pointer_Dereference.label.xml\nTemplate File: sources-sinks-81_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 476 NULL Pointer Dereference\n * BadSource:  Set data to NULL\n * GoodSource: Initialize data\n * Sinks:\n *    GoodSink: Check for NULL before attempting to print data\n *    BadSink : Print data\n * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE476_NULL_Pointer_Dereference__int_81.h\"\n\nnamespace CWE476_NULL_Pointer_Dereference__int_81\n{\n\nvoid CWE476_NULL_Pointer_Dereference__int_81_bad::action(int * data) const\n{\n    /* POTENTIAL FLAW: Attempt to use data, which may be NULL */\n    printIntLine(*data);\n}\n\n}\n#endif /* OMITBAD */\n\nnamespace CWE476_NULL_Pointer_Dereference__int_81_good\n{\n\nvoid CWE476_NULL_Pointer_Dereference__int_81_good::action(int * data) const\n{\n    /* CHECK: NULL pointer before attempting to use it */\n    if (data != NULL)\n    {\n        printIntLine(*data);\n    }\n}\n\n}\n\nvoid printIntLine(int value)\n{\n    std::cout << value << std::endl;\n}",
  "CWE476_NULL_Pointer_Dereference__int_82_bad.cpp": "You are a cybersecurity code analysis assistant.\n1. Identifies the type of vulnerability\n2. Explains why it's vulnerable\n3. Provides guidance on how to fix it (without giving the complete solution)\n\nCode:\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE476_NULL_Pointer_Dereference__int_82_bad.cpp\nLabel Definition File: CWE476_NULL_Pointer_Dereference.label.xml\nTemplate File: sources-sinks-82_bad.tmpl.cpp\n*/\n/*\n * @description\n * CWE: 476 NULL Pointer Dereference\n * BadSource:  Set data to NULL\n * GoodSource: Initialize data\n * Sinks:\n *    GoodSink: Check for NULL before attempting to print data\n *    BadSink : Print data\n * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer\n *\n * */\n#ifndef OMITBAD\n\n#include \"std_testcase.h\"\n#include \"CWE476_NULL_Pointer_Dereference__int_82.h\"\n\nnamespace CWE476_NULL_Pointer_Dereference__int_82\n{\n\nvoid CWE476_NULL_Pointer_Dereference__int_82_bad::action(int * data)\n{\n    /* POTENTIAL FLAW: Attempt to use data, which may be NULL */\n    printIntLine(*data);\n}\n\n}\n#endif /* OMITBAD */\n\nnamespace CWE476_NULL_Pointer_Dereference__int_82_good\n{\n\nvoid CWE476_NULL_Pointer_Dereference__int_82_good::action(int * data)\n{\n    /* FIXED CODE: Check for NULL before attempting to use data */\n    if (data != NULL)\n    {\n        printIntLine(*data);\n    }\n}\n\n}\n\nvoid CWE476_NULL_Pointer_Dereference__int_82_bad::action(int * data)\n{\n    /* POTENTIAL FLAW: Attempt to use data, which may be NULL */\n    printIntLine(*data);\n}\n\nvoid CWE476_NULL_Pointer_Dereference__int_82_good::action(int * data)\n{\n    /* FIXED CODE: Check for NULL before attempting to use data */\n    if (data != NULL)\n    {\n        printIntLine(*data);\n    }\n}"
}